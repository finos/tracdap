/*
 * Copyright 2022 Accenture Global Solutions Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.finos.tracdap.gateway.proxy.grpc;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http2.*;
import io.netty.util.ReferenceCountUtil;

import org.finos.tracdap.common.exception.EUnexpected;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class WebSocketsTranslator extends Http2ChannelDuplexHandler {

    // This translator enables the grpc-websockets protocol
    // grpc-websockets is a further layer on top of the grpc-web, which itself is a layer on pure gRPC
    // The handlers should be assembled in the pipeline in sequence, to make this layering work

    // Also note that the Web Socket transport serializes messages -
    // Only one request and response can be sent at a time
    // In fact, only one request can be processed over a web socket channel
    // The main use case for this transport is streaming upload of large datasets,
    // So the overhead of creating a channel is acceptable in that case

    private static final int WS_LPM_PREFIX_LENGTH = 1;

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final int connId;
    private final ByteQueue requestQueue;
    private final ByteQueue responseQueue;

    private Http2FrameStream requestStream;
    private boolean requestPrefixExpected;
    private long requestLpmRemaining;
    private long responseLpmRemaining;

    public WebSocketsTranslator(int connId) {
        this.connId = connId;
        this.requestQueue = new ByteQueue();
        this.responseQueue = new ByteQueue();
    }


    // -----------------------------------------------------------------------------------------------------------------
    // OUTBOUND LOGIC (messages going to the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {

        // Outbound messages are processed in to stages
        // First an aggregation stage, which assembles data from fragmented WS frames into a single buffer
        // Then each complete frame is processed as a single item
        // There is no requirement to line up frames / fragments with gRPC messages,
        // But it does make everything a lot easier!

        try {

            // Strict rules - no rouge object types running up and down the pipeline
            if (!(msg instanceof WebSocketFrame)) {
                log.error("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            // Other types of web socket frame might get generated by the WS codec
            // Print a warning in case it affects anything, but don't kill the connection for these
            if (!(msg instanceof BinaryWebSocketFrame)) {
                log.warn("coon = {}, Unexpected web socket frame [{}] (frame will be discarded)", connId, msg.getClass().getSimpleName());
                return;
            }

            var wsFrame = (BinaryWebSocketFrame) msg;

            // The first request in the stream is the headers frame, which has special processing
            if (requestStream == null) {
                processOutboundHeaders(ctx, wsFrame, promise);
                return;
            }

            // After the headers come a stream of LPMs, which do not align with WS frame boundaries
            // Push the frame content into a byte queue, and process incoming LPM blocks from there
            try {

                requestQueue.pushBytes(wsFrame.content().retain());

                while (requestQueue.availableBytes() > 0)
                    processOutboundLpm(ctx);

                promise.setSuccess();
            }
            catch (Throwable e) {
                promise.setFailure(e);
                throw e;
            }
        }

        // If there is an error, clean up everything
        catch (Throwable e) {
            closeEverything();
            throw e;
        }

        // Always release the incoming message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processOutboundHeaders(ChannelHandlerContext ctx, BinaryWebSocketFrame wsFrame, ChannelPromise promise) {

        requestStream = this.newStream();

        var headers = GrpcUtils.decodeHeadersFrame(wsFrame.content());

        if (log.isTraceEnabled())
            log.trace("conn = {}, Outbound headers frame: {}", connId, headers);

        var headersFrame = new DefaultHttp2HeadersFrame(headers).stream(requestStream);
        ctx.write(headersFrame, promise);
    }

    private void processOutboundLpm(ChannelHandlerContext ctx) {

        // If this is a new LPM block, read the WS EOS prefix to check for EOS
        if (requestLpmRemaining == 0 && !requestPrefixExpected) {

            // Always available when requestQueue.hasAnyBytes()
            var wsPrefix = requestQueue.popBytes(WS_LPM_PREFIX_LENGTH);

            try {

                var eos = wsPrefix.readUnsignedByte();

                if (eos == 0)
                    requestPrefixExpected = true;

                else {

                    log.trace("conn = {}, Outbound EOS marker", connId);

                    var eosFrame = new DefaultHttp2DataFrame(Unpooled.EMPTY_BUFFER, true).stream(requestStream);
                    ctx.write(eosFrame);
                }
            }
            finally {
                wsPrefix.release();
            }
        }

        // After receiving EOS == 0, there should be an LPM prefix
        // We need to peek at this to get the length of the block
        if (requestPrefixExpected) {

            if (requestQueue.hasBytes(GrpcUtils.LPM_PREFIX_LENGTH)) {

                var prefix = requestQueue.peekBytes(GrpcUtils.LPM_PREFIX_LENGTH);

                try {
                    var compress = prefix.readUnsignedByte() != 0;
                    var length = prefix.readUnsignedInt();

                    if (log.isTraceEnabled())
                        log.trace("conn = {}, Outbound LPM, compress = {}, length = {}", connId, compress, length);

                    // Include the prefix length in the remaining bytes, prefix must be sent down the pipe
                    requestLpmRemaining = GrpcUtils.LPM_PREFIX_LENGTH + length;
                    requestPrefixExpected = false;
                }
                finally {
                    prefix.release();
                }
            }
        }

        // Pass on as much content as possible up to the end of the block
        if (requestLpmRemaining > 0) {

            var chunkSize = Math.min(requestLpmRemaining, requestQueue.availableBytes());

//            if (chunkSize > 15 * 1024)
//                chunkSize = 8 * 1024;

            var chunkContent = requestQueue.popBytes((int) chunkSize);
            requestLpmRemaining -= chunkSize;

            var dataFrame = new DefaultHttp2DataFrame(chunkContent).stream(requestStream);
            ctx.write(dataFrame);
        }
    }


    // -----------------------------------------------------------------------------------------------------------------
    // INBOUND LOGIC (messages coming from the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {

        // For inbound frames, the sequence is one header frame followed by zero or more data frames
        // Trailers are already encoded into a data frame by the gRPC-Web proxy layer,
        // No additional processing is needed for grpc-websockets

        try {

            // Strict rules -the back end of this handler is speaking HTTP/2, there shouldn't be other protocols
            if (!(msg instanceof Http2Frame)) {
                log.warn("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            var frame = (Http2Frame) msg;

            // No changes to the content of header frames, just encode to bytes and send up the wire

            if (frame instanceof Http2HeadersFrame) {
                processInboundHeaders(ctx, (Http2HeadersFrame) frame);
            }

            // Data frames are already in LPM and trailers are already encoded
            // Individual messages may be split over multiple HTTP/2 data frames
            // This processing aggregates using the LPM prefix, so one message ends up in one WS data frame
            // Client code should not assume that frames don't get fragmented on their way out though!

            else if (frame instanceof Http2DataFrame) {

                // Data frames contain a stream of LPMs, which do not align with frame boundaries
                // Push the frame content into a byte queue, and process incoming LPM blocks from there

                var dataFrame = (Http2DataFrame) frame;
                responseQueue.pushBytes(dataFrame.content().retain());

                while (responseQueue.hasAnyBytes())
                    processInboundLpm(ctx);
            }

            // TODO: Send custom event to trigger close after trailers complete?

            // This may allow some communication with the handler framing the HTTP/2 content
            // E.g. the HTTP 1 -> 2 framer, web sockets framer or router link

            else {

                log.warn("conn = {}, Unexpected inbound HTTP/2 frame [{}] reached the web sockets translator",
                        connId, frame.name());
            }
        }
        catch (Throwable e) {
            closeEverything();
            throw e;
        }

        // Always release the message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processInboundHeaders(ChannelHandlerContext ctx, Http2HeadersFrame frame) {

        if (log.isTraceEnabled())
            log.trace("conn = {}, Inbound headers frame: {}", connId, frame.headers().toString());

        var wsContent = GrpcUtils.lpmHeaders(frame.headers(), ctx.alloc());
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }

    private void processInboundLpm(ChannelHandlerContext ctx) {

        // If this is a new LPM block, try to read the prefix
        if (responseLpmRemaining == 0) {

            if (responseQueue.hasBytes(GrpcUtils.LPM_PREFIX_LENGTH)) {

                var prefix = responseQueue.peekBytes(GrpcUtils.LPM_PREFIX_LENGTH);

                try {
                    var compressFlag = prefix.readUnsignedByte();
                    var trailers = (compressFlag & (1 << 7)) != 0;
                    var compress = (compressFlag & 1) != 0;
                    var length = prefix.readUnsignedInt();

                    if (log.isTraceEnabled()) {

                        log.trace(
                                "conn = {}, Inbound LPM, trailers = {}, compress = {}, length = {}",
                                connId, trailers, compress, length);
                    }

                    // Include the prefix length in the remaining bytes, prefix must be sent down the pipe
                    responseLpmRemaining = GrpcUtils.LPM_PREFIX_LENGTH + length;
                }
                finally {
                    prefix.release();
                }
            }
        }

        // Pass on as much content as possible up to the end of the block
        // Trailer frames are already encoded by the gRPC-Web translation layer, so can be treated as normal
        if (responseLpmRemaining > 0) {

            var chunkSize = Math.min(responseLpmRemaining, responseQueue.availableBytes());
            var chunkContent = responseQueue.popBytes((int) chunkSize);
            responseLpmRemaining -= chunkSize;

            var dataFrame = new BinaryWebSocketFrame(chunkContent);
            ctx.fireChannelRead(dataFrame);
        }
    }

    private void closeEverything() {

        // Clean up everything in the event of an error
        // In normal processing, resources will be closed as they are dispatched

        if (requestQueue.hasAnyBytes()) {
            requestQueue.destroyQueue();
        }

        if (responseQueue.hasAnyBytes()) {
            responseQueue.destroyQueue();
        }

        requestStream = null;
        requestPrefixExpected = false;
        requestLpmRemaining = 0;
        responseLpmRemaining = 0;
    }
}