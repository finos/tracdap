/*
 * Copyright 2022 Accenture Global Solutions Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.finos.tracdap.gateway.proxy.grpc;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.codec.http2.*;
import io.netty.util.ReferenceCountUtil;

import org.finos.tracdap.common.exception.ENetwork;
import org.finos.tracdap.common.exception.EUnexpected;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;

import static org.finos.tracdap.gateway.proxy.grpc.GrpcUtils.LPM_PREFIX_LENGTH;


public class WebSocketsTranslator extends Http2ChannelDuplexHandler {

    // This translator enables the grpc-websockets protocol
    // grpc-websockets is a further layer on top of the grpc-web, which itself is a layer on pure gRPC
    // The handlers should be assembled in the pipeline in sequence, to make this layering work

    // Also note that the Web Socket transport serializes messages -
    // Only one request and response can be sent at a time
    // In fact, only one request can be processed over a web socket channel
    // The main use case for this transport is streaming upload of large datasets,
    // So the overhead of creating a channel is acceptable in that case

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final int connId;

    // Outbound LPM state
    private Http2FrameStream requestStream;
    private final byte[] prefixBytes;
    private int prefixRemaining;
    private int lpmRemaining;
    private boolean eosFlag;

    public WebSocketsTranslator(int connId) {

        this.connId = connId;
        this.prefixBytes = new byte[LPM_PREFIX_LENGTH];
    }


    // -----------------------------------------------------------------------------------------------------------------
    // OUTBOUND LOGIC (messages going to the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {

        // Outbound data has to be processed on the way through
        // The WS EOS marker bytes need to be removed
        // Also we add an explicit outbound EOS to the translated stream
        // Downstream handlers should not need to look at message content to get EOS

        try {

            // Strict rules - no rouge object types running up and down the pipeline
            if (!(msg instanceof WebSocketFrame)) {
                log.error("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            var wsFrame = (WebSocketFrame) msg;

            // Other types of web socket frame might get generated by the WS codec
            // Print a warning in case it affects anything, but don't kill the connection for these
            if (!(msg instanceof BinaryWebSocketFrame) && !(msg instanceof ContinuationWebSocketFrame)) {
                log.warn("coon = {}, Unexpected web socket frame [{}] (frame will be discarded)", connId, msg.getClass().getSimpleName());
                return;
            }

            // The first request in the stream is the headers frame, which has special processing
            // Also first message cannot be a continuation frame!
            if (requestStream == null) {
                
                if (!(msg instanceof BinaryWebSocketFrame)){
                    log.warn("coon = {}, Unexpected web socket frame [{}] (frame will be discarded)", connId, msg.getClass().getSimpleName());
                    return;
                }
                
                processOutboundHeaders(ctx, wsFrame, promise);
            }
            else {
                processOutboundData(ctx, wsFrame, promise);
            }
        }

        // Always release the incoming message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processOutboundHeaders(ChannelHandlerContext ctx, WebSocketFrame wsFrame, ChannelPromise promise) {

        // The initial WS headers come in a binary frame, they are converted into an HTTP/2 headers frame

        requestStream = this.newStream();

        var frameSize = wsFrame.content().readableBytes();
        var headers = GrpcUtils.decodeHeadersFrame(wsFrame.content());

        if (log.isTraceEnabled())
            log.trace("conn = {}, outbound headers frame: size = [{}], {}", connId, frameSize, headers);

        var headersFrame = new DefaultHttp2HeadersFrame(headers).stream(requestStream);
        ctx.write(headersFrame, promise);
    }

    private void processOutboundData(ChannelHandlerContext ctx, WebSocketFrame wsFrame, ChannelPromise promise) {

        // After the initial headers, we can sniff the stream to pick out LPMs
        // We need to read the prefix, then skip ahead to next message
        // Slices are sent with the WS EOS markers removed (i.e. one byte is removed between messages)

        // Try to slice as little as possible and don't hold any buffers after a frame is processed
        // Don't try to get 1 LPM per frame (adds complexity, they get broken apart anyway)

        try {

            var frameBytes = wsFrame.content();
            var frameSize = frameBytes.readableBytes();
            var lpmOffset = 0;

            if (log.isTraceEnabled())
                log.trace("conn = {}, outbound data frame: size = [{}]", connId, frameSize);

            while (frameBytes.readerIndex() < frameSize && !eosFlag) {

                // If this is a new LPM, start by looking for the websocket EOS flag
                if (lpmRemaining == 0 && prefixRemaining == 0) {

                    sniffWsPrefix(frameBytes);

                    // If the EOS marker is received, do not process more LPMs (it should be the last one)
                    // Otherwise prepare to read an LPM, starting at the current reader index
                    if (eosFlag)
                        break;
                    else {
                        prefixRemaining = LPM_PREFIX_LENGTH;
                        lpmOffset = frameBytes.readerIndex();
                    }
                }

                // So long as EOS = 0, expect an LPM prefix next
                if (prefixRemaining > 0) {
                    sniffLpmPrefix(frameBytes);
                }

                // Consume bytes until the end of the frame or LPM, whichever comes sooner
                if (lpmRemaining > 0) {
                    consumeLpmBytes(ctx, frameBytes, lpmOffset);
                }
            }

            if (frameBytes.readerIndex() != frameSize) {
                log.error("conn = {}, invalid gRPC data stream (websockets), message offsets don't add up", connId);
                throw new ENetwork("Invalid gRPC data stream (websockets)");
            }

            // When the EOS marker appears, send an explicit EOS down the pipe
            // (don't rely on handlers inspecting the data stream)
            if (eosFlag) {
                sendExplicitEos(ctx);
            }

            promise.setSuccess();
        }
        catch (Throwable e) {
            promise.setFailure(e);
            throw e;
        }
    }

    private void sniffWsPrefix(ByteBuf frameBytes) {

        var eos = frameBytes.readUnsignedByte();

        // Once EOS flag is set, it should not be unset
        if (eos != 0)
            eosFlag = true;
    }

    private void sniffLpmPrefix(ByteBuf frameBytes) {

        var prefixAvailable = Math.min(frameBytes.readableBytes(), LPM_PREFIX_LENGTH);
        var prefixOffset = LPM_PREFIX_LENGTH - prefixRemaining;

        frameBytes.readBytes(prefixBytes, prefixOffset, prefixAvailable);

        prefixRemaining -= prefixAvailable;

        if (prefixRemaining == 0) {

            // Compression flag not currently used
            // Any compressed data, just pass it through as-is!

            lpmRemaining = (int) GrpcUtils.readLpmLength(prefixBytes);
        }

        if (log.isTraceEnabled() && lpmRemaining > 0) {
            log.trace("conn = {}, outbound LPM, length = {}, compress = {}", connId, lpmRemaining, GrpcUtils.readLpmFlag(prefixBytes));
        }
    }

    private void consumeLpmBytes(ChannelHandlerContext ctx, ByteBuf frameBytes, int lpmOffset) {

        // If a portion of the prefix has been read in this frame, those bytes need to be included
        // The slice includes the LPM prefix and message, but not the WS EOS marker bytes
        var slicePrefixSize = frameBytes.readerIndex() - lpmOffset;

        var lpmAvailable = Math.min(frameBytes.readableBytes(), lpmRemaining);
        var lpmSliceSize = slicePrefixSize + lpmAvailable;

        var lpmSlice = frameBytes.slice(lpmOffset, lpmSliceSize).retain();
        var lpmFrame = new DefaultHttp2DataFrame(lpmSlice).stream(requestStream);
        ctx.write(lpmFrame);

        frameBytes.readerIndex(frameBytes.readerIndex() + lpmAvailable);
        lpmRemaining -= lpmAvailable;
    }

    private void sendExplicitEos(ChannelHandlerContext ctx) {

        if (log.isTraceEnabled()) {
            log.trace("conn = {}, EOS marker seen, sending outbound EOS", connId);
        }

        var eosFrame = new DefaultHttp2DataFrame(Unpooled.EMPTY_BUFFER, true).stream(requestStream);
        ctx.write(eosFrame);
        ctx.flush();
    }


    // -----------------------------------------------------------------------------------------------------------------
    // INBOUND LOGIC (messages coming from the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void channelRead(@Nonnull ChannelHandlerContext ctx, @Nonnull Object msg) throws Exception {

        // The client must account for LPM / frame boundaries being misaligned, it can't be reliably prevented
        // Since we don't need to inspect the response stream, it can just pass it through with minimal processing
        // The HTTP/2 EOS marker can signal the request is complete

        try {

            // Strict rules -the back end of this handler is speaking HTTP/2, there shouldn't be other protocols
            if (!(msg instanceof Http2Frame)) {
                log.warn("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            var frame = (Http2Frame) msg;
            var eos = false;

            // Handlers for incoming HTTP/2 frames

            if (frame instanceof Http2HeadersFrame) {

                var headersFrame = (Http2HeadersFrame) frame;
                processInboundHeaders(ctx, headersFrame);

                eos = headersFrame.isEndStream();
            }

            else if (frame instanceof Http2DataFrame) {

                var dataFrame = (Http2DataFrame) frame;
                processInboundData(ctx, dataFrame);

                eos = dataFrame.isEndStream();
            }

            else {

                // Drop unexpected frame types with a warning (e.g. a stray ping)!
                log.warn("conn = {}, unexpected inbound frame [{}] in web sockets translator", connId, frame.name());
            }

            // grpc-websockets protocol only supports one call per connection
            // If the response is completed (HTTP/2 EOS), send an explicit CLOSE frame to the client
            // Anyway, the client will know anyway when it gets a trailers frame with grpc-status
            // But this is more definite and guards against unexpected error conditions

            if (eos) {

                var closeFrame = new CloseWebSocketFrame(WebSocketCloseStatus.NORMAL_CLOSURE, "request complete");
                ctx.fireChannelRead(closeFrame);
                ctx.flush();
            }


        }

        // Always release the message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processInboundHeaders(ChannelHandlerContext ctx, Http2HeadersFrame frame) {

        // No changes to the content of header frames, just encode as LPM and send up the wire

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {}} frame: {}", connId, frame.name(), frame.headers().toString());

        var wsContent = GrpcUtils.lpmHeaders(frame.headers(), ctx.alloc());
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }

    private void processInboundData(ChannelHandlerContext ctx, Http2DataFrame frame) {

        // Data frames are sent through as-is
        // It may be that LPM and frame boundaries are not aligned
        // But since there is no need to inspect the LPM, that doesn't matter

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {} frame: size = [{}]", connId, frame.name(), frame.content().readableBytes());

        var wsContent = frame.content().retain();
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }
}