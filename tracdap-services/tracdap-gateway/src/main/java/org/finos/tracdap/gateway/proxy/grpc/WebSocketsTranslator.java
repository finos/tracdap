/*
 * Copyright 2022 Accenture Global Solutions Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.finos.tracdap.gateway.proxy.grpc;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketCloseStatus;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http2.*;
import io.netty.util.ReferenceCountUtil;

import org.finos.tracdap.common.exception.EUnexpected;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;

import static org.finos.tracdap.gateway.proxy.grpc.GrpcUtils.LPM_PREFIX_LENGTH;


public class WebSocketsTranslator extends Http2ChannelDuplexHandler {

    // This translator enables the grpc-websockets protocol
    // grpc-websockets is a further layer on top of the grpc-web, which itself is a layer on pure gRPC
    // The handlers should be assembled in the pipeline in sequence, to make this layering work

    // Also note that the Web Socket transport serializes messages -
    // Only one request and response can be sent at a time
    // In fact, only one request can be processed over a web socket channel
    // The main use case for this transport is streaming upload of large datasets,
    // So the overhead of creating a channel is acceptable in that case

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final int connId;

    private Http2FrameStream requestStream;
    private final byte[] prefixBytes;
    private int prefixRemaining;
    private long lpmRemaining;

    public WebSocketsTranslator(int connId) {

        this.connId = connId;
        this.prefixBytes = new byte[LPM_PREFIX_LENGTH];
    }


    // -----------------------------------------------------------------------------------------------------------------
    // OUTBOUND LOGIC (messages going to the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {

        // Outbound messages are processed in to stages
        // First an aggregation stage, which assembles data from fragmented WS frames into a single buffer
        // Then each complete frame is processed as a single item
        // There is no requirement to line up frames / fragments with gRPC messages,
        // But it does make everything a lot easier!

        try {

            // Strict rules - no rouge object types running up and down the pipeline
            if (!(msg instanceof WebSocketFrame)) {
                log.error("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            // Other types of web socket frame might get generated by the WS codec
            // Print a warning in case it affects anything, but don't kill the connection for these
            if (!(msg instanceof BinaryWebSocketFrame)) {
                log.warn("coon = {}, Unexpected web socket frame [{}] (frame will be discarded)", connId, msg.getClass().getSimpleName());
                return;
            }

            var wsFrame = (BinaryWebSocketFrame) msg;

            // The first request in the stream is the headers frame, which has special processing
            if (requestStream == null) {
                processOutboundHeaders(ctx, wsFrame, promise);
            }
            else {
                processOutboundData(ctx, wsFrame, promise);
            }
        }

        // Always release the incoming message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {

        log.error(cause.getMessage(), cause);

        super.exceptionCaught(ctx, cause);
    }

    private void processOutboundHeaders(ChannelHandlerContext ctx, BinaryWebSocketFrame wsFrame, ChannelPromise promise) {

        requestStream = this.newStream();

        var frameSize = wsFrame.content().readableBytes();
        var headers = GrpcUtils.decodeHeadersFrame(wsFrame.content());

        if (log.isTraceEnabled())
            log.trace("conn = {}, outbound headers frame: size = [{}], {}", connId, frameSize, headers);

        var headersFrame = new DefaultHttp2HeadersFrame(headers).stream(requestStream);
        ctx.write(headersFrame, promise);
    }

    private void processOutboundData(ChannelHandlerContext ctx, BinaryWebSocketFrame wsFrame, ChannelPromise promise) {

        try {

            var frameBytes = wsFrame.content();
            var frameSize = frameBytes.readableBytes();
            var frameOffset = 0;
            var lpmOffset = 0;
            var eos = (short) 0;

            if (log.isTraceEnabled())
                log.trace("conn = {}, outbound data frame: size = [{}]", connId, frameSize);

            while (frameOffset < frameSize) {

                // If this is a new LPM, start by looking for the websocket EOS flag
                if (lpmRemaining == 0 && prefixRemaining == 0) {

                    eos = frameBytes.getUnsignedByte(frameOffset);
                    frameOffset += 1;
                    lpmOffset += 1;

                    if (eos != 0)
                        break;
                    else
                        prefixRemaining = LPM_PREFIX_LENGTH;
                }

                // After EOS = 0, expect an LPM prefix
                if (prefixRemaining > 0) {

                    var prefixAvailable = Math.min(frameSize - frameOffset, LPM_PREFIX_LENGTH);
                    var prefixOffset = LPM_PREFIX_LENGTH - prefixRemaining;

                    frameBytes.getBytes(frameOffset, prefixBytes, prefixOffset, prefixAvailable);

                    prefixRemaining -= prefixAvailable;
                    frameOffset += prefixAvailable;

                    if (prefixRemaining == 0) {

                        // Compression flag not currently used
                        // Any compressed data, just pass it through as-is!

                        lpmRemaining = GrpcUtils.readLpmLength(prefixBytes);
                    }

                    if (log.isTraceEnabled() && lpmRemaining > 0) {
                        log.trace("conn = {}, outbound LPM, length = {}, compress = {}", connId, lpmRemaining, GrpcUtils.readLpmFlag(prefixBytes));
                    }
                }

                // Skip over all available bytes to the end of the LPM
                if (lpmRemaining > 0) {

                    var lpmAvailable = Math.min(frameSize - frameOffset, lpmRemaining);

                    lpmRemaining -= lpmAvailable;
                    frameOffset += lpmAvailable;
                }

                var lpmSlice = frameBytes.slice(lpmOffset, frameOffset - lpmOffset).retain();
                var lpmFrame = new DefaultHttp2DataFrame(lpmSlice).stream(requestStream);
                ctx.write(lpmFrame);
            }

            if (frameOffset != frameSize) {
                log.error("conn = {}, invalid grpc websockets stream", connId);
                throw new EUnexpected();  // todo error
            }

            if (eos != 0) {

                if (log.isTraceEnabled()) {
                    log.trace("conn = {}, EOS marker seen, sending outbound EOS", connId);
                }

                var eosFrame = new DefaultHttp2DataFrame(Unpooled.EMPTY_BUFFER, true).stream(requestStream);
                ctx.write(eosFrame);
                ctx.flush();
            }

            promise.setSuccess();
        }
        catch (Throwable e) {
            promise.setFailure(e);
        }
    }


    // -----------------------------------------------------------------------------------------------------------------
    // INBOUND LOGIC (messages coming from the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void channelRead(@Nonnull ChannelHandlerContext ctx, @Nonnull Object msg) throws Exception {

        // The client must account for LPM / frame boundaries being misaligned, it can't be reliably prevented
        // Since we don't need to inspect the response stream, it can just pass it through with minimal processing
        // The HTTP/2 EOS marker can signal the request is complete

        try {

            // Strict rules -the back end of this handler is speaking HTTP/2, there shouldn't be other protocols
            if (!(msg instanceof Http2Frame)) {
                log.warn("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            var frame = (Http2Frame) msg;
            var eos = false;

            // Handlers for incoming HTTP/2 frames

            if (frame instanceof Http2HeadersFrame) {

                var headersFrame = (Http2HeadersFrame) frame;
                processInboundHeaders(ctx, headersFrame);

                eos = headersFrame.isEndStream();
            }

            else if (frame instanceof Http2DataFrame) {

                var dataFrame = (Http2DataFrame) frame;
                processInboundData(ctx, dataFrame);

                eos = dataFrame.isEndStream();
            }

            else {

                // Drop unexpected frame types with a warning (e.g. a stray ping)!
                log.warn("conn = {}, unexpected inbound frame [{}] in web sockets translator", connId, frame.name());
            }

            // grpc-websockets protocol only supports one call per connection
            // If the response is completed (HTTP/2 EOS), send an explicit CLOSE frame to the client
            // Anyway, the client will know anyway when it gets a trailers frame with grpc-status
            // But this is more definite and guards against unexpected error conditions

            if (eos) {

                var closeFrame = new CloseWebSocketFrame(WebSocketCloseStatus.NORMAL_CLOSURE);
                ctx.fireChannelRead(closeFrame);
                ctx.flush();
            }


        }

        // Always release the message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processInboundHeaders(ChannelHandlerContext ctx, Http2HeadersFrame frame) {

        // No changes to the content of header frames, just encode as LPM and send up the wire

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {}} frame: {}", connId, frame.name(), frame.headers().toString());

        var wsContent = GrpcUtils.lpmHeaders(frame.headers(), ctx.alloc());
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }

    private void processInboundData(ChannelHandlerContext ctx, Http2DataFrame frame) {

        // Data frames are sent through as-is
        // It may be that LPM and frame boundaries are not aligned
        // But since there is no need to inspect the LPM, that doesn't matter

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {} frame: size = [{}]", connId, frame.name(), frame.content().readableBytes());

        var wsContent = frame.content().retain();
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }
}