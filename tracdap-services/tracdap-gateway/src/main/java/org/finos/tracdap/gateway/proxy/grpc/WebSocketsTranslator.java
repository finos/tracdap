/*
 * Copyright 2022 Accenture Global Solutions Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.finos.tracdap.gateway.proxy.grpc;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketCloseStatus;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http2.*;
import io.netty.util.ReferenceCountUtil;

import org.finos.tracdap.common.exception.EUnexpected;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;


public class WebSocketsTranslator extends Http2ChannelDuplexHandler {

    // This translator enables the grpc-websockets protocol
    // grpc-websockets is a further layer on top of the grpc-web, which itself is a layer on pure gRPC
    // The handlers should be assembled in the pipeline in sequence, to make this layering work

    // Also note that the Web Socket transport serializes messages -
    // Only one request and response can be sent at a time
    // In fact, only one request can be processed over a web socket channel
    // The main use case for this transport is streaming upload of large datasets,
    // So the overhead of creating a channel is acceptable in that case

    private static final int WS_LPM_PREFIX_LENGTH = 1;

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final int connId;

    private Http2FrameStream requestStream;
    private final ByteQueue requestQueue;
    private boolean requestPrefixExpected;
    private long requestLpmRemaining;

    public WebSocketsTranslator(int connId) {

        this.connId = connId;

        this.requestQueue = new ByteQueue();
    }


    // -----------------------------------------------------------------------------------------------------------------
    // OUTBOUND LOGIC (messages going to the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {

        // Outbound messages are processed in to stages
        // First an aggregation stage, which assembles data from fragmented WS frames into a single buffer
        // Then each complete frame is processed as a single item
        // There is no requirement to line up frames / fragments with gRPC messages,
        // But it does make everything a lot easier!

        try {

            // Strict rules - no rouge object types running up and down the pipeline
            if (!(msg instanceof WebSocketFrame)) {
                log.error("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            // Other types of web socket frame might get generated by the WS codec
            // Print a warning in case it affects anything, but don't kill the connection for these
            if (!(msg instanceof BinaryWebSocketFrame)) {
                log.warn("coon = {}, Unexpected web socket frame [{}] (frame will be discarded)", connId, msg.getClass().getSimpleName());
                return;
            }

            var wsFrame = (BinaryWebSocketFrame) msg;

            // The first request in the stream is the headers frame, which has special processing
            if (requestStream == null) {
                processOutboundHeaders(ctx, wsFrame, promise);
                return;
            }

            // After the headers come a stream of LPMs, which do not align with WS frame boundaries
            // Push the frame content into a byte queue, and process incoming LPM blocks from there
            try {

                requestQueue.pushBytes(wsFrame.content().retain());

                while (requestQueue.availableBytes() > 0)
                    processOutboundLpm(ctx);

                promise.setSuccess();
            }
            catch (Throwable e) {
                promise.setFailure(e);
                throw e;
            }
        }

        // If there is an error, clean up everything
        catch (Throwable e) {
            closeEverything();
            throw e;
        }

        // Always release the incoming message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processOutboundHeaders(ChannelHandlerContext ctx, BinaryWebSocketFrame wsFrame, ChannelPromise promise) {

        requestStream = this.newStream();

        var headers = GrpcUtils.decodeHeadersFrame(wsFrame.content());

        if (log.isTraceEnabled())
            log.trace("conn = {}, Outbound headers frame: {}", connId, headers);

        var headersFrame = new DefaultHttp2HeadersFrame(headers).stream(requestStream);
        ctx.write(headersFrame, promise);
    }

    private void processOutboundLpm(ChannelHandlerContext ctx) {

        // If this is a new LPM block, read the WS EOS prefix to check for EOS
        if (requestLpmRemaining == 0 && !requestPrefixExpected) {

            // Always available when requestQueue.hasAnyBytes()
            var wsPrefix = requestQueue.popBytes(WS_LPM_PREFIX_LENGTH);

            try {

                var eos = wsPrefix.readUnsignedByte();

                if (eos == 0)
                    requestPrefixExpected = true;

                else {

                    log.trace("conn = {}, Outbound EOS marker", connId);

                    var eosFrame = new DefaultHttp2DataFrame(Unpooled.EMPTY_BUFFER, true).stream(requestStream);
                    ctx.write(eosFrame);
                }
            }
            finally {
                wsPrefix.release();
            }
        }

        // After receiving EOS == 0, there should be an LPM prefix
        // We need to peek at this to get the length of the block
        if (requestPrefixExpected) {

            if (requestQueue.hasBytes(GrpcUtils.LPM_PREFIX_LENGTH)) {

                var prefix = requestQueue.peekBytes(GrpcUtils.LPM_PREFIX_LENGTH);

                try {
                    var compress = prefix.readUnsignedByte() != 0;
                    var length = prefix.readUnsignedInt();

                    if (log.isTraceEnabled())
                        log.trace("conn = {}, Outbound LPM, compress = {}, length = {}", connId, compress, length);

                    // Include the prefix length in the remaining bytes, prefix must be sent down the pipe
                    requestLpmRemaining = GrpcUtils.LPM_PREFIX_LENGTH + length;
                    requestPrefixExpected = false;
                }
                finally {
                    prefix.release();
                }
            }
        }

        // Pass on as much content as possible up to the end of the block
        if (requestLpmRemaining > 0) {

            var chunkSize = Math.min(requestLpmRemaining, requestQueue.availableBytes());

//            if (chunkSize > 15 * 1024)
//                chunkSize = 8 * 1024;

            var chunkContent = requestQueue.popBytes((int) chunkSize);
            requestLpmRemaining -= chunkSize;

            var dataFrame = new DefaultHttp2DataFrame(chunkContent).stream(requestStream);
            ctx.write(dataFrame);
        }
    }


    // -----------------------------------------------------------------------------------------------------------------
    // INBOUND LOGIC (messages coming from the server)
    // -----------------------------------------------------------------------------------------------------------------


    @Override
    public void channelRead(@Nonnull ChannelHandlerContext ctx, @Nonnull Object msg) throws Exception {

        // The client must account for LPM / frame boundaries being misaligned, it can't be reliably prevented
        // Since we don't need to inspect the response stream, it can just pass it through with minimal processing
        // The HTTP/2 EOS marker can signal the request is complete

        try {

            // Strict rules -the back end of this handler is speaking HTTP/2, there shouldn't be other protocols
            if (!(msg instanceof Http2Frame)) {
                log.warn("coon = {}, Unexpected message of type [{}]", connId, msg.getClass().getSimpleName());
                throw new EUnexpected();
            }

            var frame = (Http2Frame) msg;
            var eos = false;

            // Handlers for incoming HTTP/2 frames

            if (frame instanceof Http2HeadersFrame) {

                var headersFrame = (Http2HeadersFrame) frame;
                processInboundHeaders(ctx, headersFrame);

                eos = headersFrame.isEndStream();
            }

            else if (frame instanceof Http2DataFrame) {

                var dataFrame = (Http2DataFrame) frame;
                processInboundData(ctx, dataFrame);

                eos = dataFrame.isEndStream();
            }

            else {

                // Drop unexpected frame types with a warning (e.g. a stray ping)!
                log.warn("conn = {}, unexpected inbound frame [{}] in web sockets translator", connId, frame.name());
            }

            // grpc-websockets protocol only supports one call per connection
            // If the response is completed (HTTP/2 EOS), send an explicit CLOSE frame to the client
            // Anyway, the client will know anyway when it gets a trailers frame with grpc-status
            // But this is more definite and guards against unexpected error conditions

            if (eos) {

                var closeFrame = new CloseWebSocketFrame(WebSocketCloseStatus.NORMAL_CLOSURE);
                ctx.fireChannelRead(closeFrame);
                ctx.flush();
            }


        }
        catch (Throwable e) {
            closeEverything();
            throw e;
        }

        // Always release the message, this has been processed
        finally {
            ReferenceCountUtil.release(msg);
        }
    }

    private void processInboundHeaders(ChannelHandlerContext ctx, Http2HeadersFrame frame) {

        // No changes to the content of header frames, just encode as LPM and send up the wire

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {}} frame: {}", connId, frame.name(), frame.headers().toString());

        var wsContent = GrpcUtils.lpmHeaders(frame.headers(), ctx.alloc());
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }

    private void processInboundData(ChannelHandlerContext ctx, Http2DataFrame frame) {

        // Data frames are sent through as-is
        // It may be that LPM and frame boundaries are not aligned
        // But since there is no need to inspect the LPM, that doesn't matter

        if (log.isTraceEnabled())
            log.trace("conn = {}, inbound {} frame: size = [{}]", connId, frame.name(), frame.content().readableBytes());

        var wsContent = frame.content().retain();
        var wsFrame = new BinaryWebSocketFrame(wsContent);

        ctx.fireChannelRead(wsFrame);
    }

    private void closeEverything() {

        // Clean up everything in the event of an error
        // In normal processing, resources will be closed as they are dispatched

        if (requestQueue.hasAnyBytes()) {
            requestQueue.destroyQueue();
        }

        requestStream = null;
        requestPrefixExpected = false;
        requestLpmRemaining = 0;
    }
}